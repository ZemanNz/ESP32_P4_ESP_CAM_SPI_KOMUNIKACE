#include <stdio.h>
#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"
#include "freertos/queue.h"
#include "driver/spi_master.h"
#include "driver/gpio.h"
#include "esp_timer.h"

// === KONFIGURACE P4 ===
#define GPIO_HANDSHAKE      20
#define GPIO_SCLK           21
#define GPIO_MOSI           22
#define GPIO_MISO           24   
#define GPIO_CS             25

#define SENDER_HOST         SPI2_HOST

static QueueHandle_t rdySem;

static void IRAM_ATTR gpio_handshake_isr_handler(void* arg)
{
    static uint32_t lasthandshaketime_us;
    uint32_t currtime_us = esp_timer_get_time();
    uint32_t diff = currtime_us - lasthandshaketime_us;
    if (diff < 1000) return; 
    lasthandshaketime_us = currtime_us;

    BaseType_t mustYield = false;
    xSemaphoreGiveFromISR(rdySem, &mustYield);
    if (mustYield) portYIELD_FROM_ISR();
}

void app_main(void)
{
    esp_err_t ret;
    spi_device_handle_t handle;

    spi_bus_config_t buscfg = {
        .mosi_io_num = GPIO_MOSI,
        .miso_io_num = GPIO_MISO,
        .sclk_io_num = GPIO_SCLK,
        .quadwp_io_num = -1,
        .quadhd_io_num = -1,
        .max_transfer_sz = 4096,
    };

    spi_device_interface_config_t devcfg = {
        .command_bits = 0,
        .address_bits = 0,
        .dummy_bits = 0,
        .clock_speed_hz = 1000000, 
        .duty_cycle_pos = 128,      
        
        // Vracíme Mode 0 (protože budeme opravovat sw)
        .mode = 0,
        
        .spics_io_num = GPIO_CS,
        .cs_ena_pretrans = 16,
        .cs_ena_posttrans = 4,
        .input_delay_ns = 0, 
        .queue_size = 3
    };

    gpio_config_t io_conf = {
        .intr_type = GPIO_INTR_POSEDGE,
        .mode = GPIO_MODE_INPUT,
        .pull_up_en = GPIO_PULLUP_ENABLE,
        .pin_bit_mask = (1ULL << GPIO_HANDSHAKE),
    };

    rdySem = xSemaphoreCreateBinary();
    gpio_config(&io_conf);
    gpio_install_isr_service(0);
    gpio_isr_handler_add(GPIO_HANDSHAKE, gpio_handshake_isr_handler, NULL);

    ret = spi_bus_initialize(SENDER_HOST, &buscfg, SPI_DMA_CH_AUTO);
    ESP_ERROR_CHECK(ret);
    
    gpio_set_pull_mode(GPIO_MISO, GPIO_PULLUP_ONLY);

    ret = spi_bus_add_device(SENDER_HOST, &devcfg, &handle);
    ESP_ERROR_CHECK(ret);

    xSemaphoreGive(rdySem);

    char sendbuf[128] = {0};
    uint8_t recvbuf[128] = {0}; // Změna na uint8_t pro lepší práci s bity
    spi_transaction_t t;
    memset(&t, 0, sizeof(t));
    int n = 0;

    printf("--- MASTER P4 (Software Fix) ---\n");

    while (1) {
        memset(recvbuf, 0, sizeof(recvbuf)); 
        snprintf(sendbuf, sizeof(sendbuf), "Msg %d from P4", n);
        
        t.length = sizeof(sendbuf) * 8;
        t.tx_buffer = sendbuf;
        t.rx_buffer = recvbuf;

        printf("Waiting for Slave...\n");
        xSemaphoreTake(rdySem, portMAX_DELAY);

        ret = spi_device_transmit(handle, &t);
        
        if (ret == ESP_OK) {
            printf("Sent: %s\n", sendbuf);

            // --- TADY JE TA OPRAVA ---
            // Posuneme každý bajt o 1 bit doprava, aby se z 0x90 stalo 0x48 ('H')
            for(int i=0; i<128; i++) {
                recvbuf[i] = (recvbuf[i] >> 1);
            }
            // -------------------------

            printf("Received String: %s\n", recvbuf);
            printf("Received HEX:    %02X %02X %02X %02X\n", recvbuf[0], recvbuf[1], recvbuf[2], recvbuf[3]);
        }

        n++;
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}
//P4
// Received String: Hello #19
// Received HEX:    48 65 6C 6C
// Waiting for Slave...
// Sent: Msg 12 from P4
// Received String: Hello #20
// Received HEX:    48 65 6C 6C



//WROOM
// Received from P4: Msg 9 from P4
// Received from P4: Msg 10 from P4
// Received from P4: Msg 11 from P4
// Received from P4: Msg 12 from P4