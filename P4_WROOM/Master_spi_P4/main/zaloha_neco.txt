// #include <stdio.h>
// #include <stdint.h>
// #include <stddef.h>
// #include <string.h>
// #include "esp_log.h"
// #include "freertos/FreeRTOS.h"
// #include "freertos/task.h"
// #include "freertos/semphr.h"
// #include "freertos/queue.h"
// #include "driver/spi_master.h"
// #include "driver/gpio.h"
// #include "esp_timer.h"

// // ==========================================================
// // KONFIGURACE MASTER (ESP32-P4)
// // ==========================================================
// #define GPIO_HANDSHAKE      20   // Oranžový drát
// #define GPIO_SCLK           21   // Žlutý
// #define GPIO_MOSI           22   // Modrý
// #define GPIO_MISO           24   // Zelený
// #define GPIO_CS             25   // Bílý

// #define SENDER_HOST         SPI2_HOST

// static QueueHandle_t rdySem;

// // Obsluha přerušení od Handshake pinu
// static void IRAM_ATTR gpio_handshake_isr_handler(void* arg)
// {
//     static uint32_t lasthandshaketime_us;
//     uint32_t currtime_us = esp_timer_get_time();
//     uint32_t diff = currtime_us - lasthandshaketime_us;
//     if (diff < 1000) return; // Debounce 1ms
//     lasthandshaketime_us = currtime_us;

//     BaseType_t mustYield = false;
//     xSemaphoreGiveFromISR(rdySem, &mustYield);
//     if (mustYield) portYIELD_FROM_ISR();
// }

// void app_main(void)
// {
//     esp_err_t ret;
//     spi_device_handle_t handle;

//     // 1. Konfigurace sběrnice
//     spi_bus_config_t buscfg = {
//         .mosi_io_num = GPIO_MOSI,
//         .miso_io_num = GPIO_MISO,
//         .sclk_io_num = GPIO_SCLK,
//         .quadwp_io_num = -1,
//         .quadhd_io_num = -1,
//         .max_transfer_sz = 4096,
//     };

//     // 2. Konfigurace zařízení (Slave)
//     spi_device_interface_config_t devcfg = {
//         .command_bits = 0,
//         .address_bits = 0,
//         .dummy_bits = 0,
//         .clock_speed_hz = 1000000,  // <--- ZDE NASTAVENO 1 MHz
//         .duty_cycle_pos = 128,      // 50% střída
//         .mode = 0,
//         .spics_io_num = GPIO_CS,
//         .cs_ena_posttrans = 3,
//         .queue_size = 3
//     };

//     // 3. Handshake pin (Input)
//     gpio_config_t io_conf = {
//         .intr_type = GPIO_INTR_POSEDGE,
//         .mode = GPIO_MODE_INPUT,
//         .pull_up_en = GPIO_PULLUP_ENABLE,
//         .pin_bit_mask = (1ULL << GPIO_HANDSHAKE),
//     };

//     rdySem = xSemaphoreCreateBinary();
//     gpio_config(&io_conf);
//     gpio_install_isr_service(0);
//     gpio_isr_handler_add(GPIO_HANDSHAKE, gpio_handshake_isr_handler, NULL);

//     // Init SPI
//     ret = spi_bus_initialize(SENDER_HOST, &buscfg, SPI_DMA_CH_AUTO);
//     ESP_ERROR_CHECK(ret);
//     ret = spi_bus_add_device(SENDER_HOST, &devcfg, &handle);
//     ESP_ERROR_CHECK(ret);

//     // Reset handshake
//     xSemaphoreGive(rdySem);

//     char sendbuf[128] = {0};
//     char recvbuf[128] = {0};
//     spi_transaction_t t;
//     memset(&t, 0, sizeof(t));
//     int n = 0;

//     printf("--- MASTER P4 STARTED (1 MHz) ---\n");

//     while (1) {
//         memset(recvbuf, 0, sizeof(recvbuf)); // Vyčistit buffer pro příjem
//         snprintf(sendbuf, sizeof(sendbuf), "Message %d from P4 (1MHz)", n);
        
//         t.length = sizeof(sendbuf) * 8;
//         t.tx_buffer = sendbuf;
//         t.rx_buffer = recvbuf;

//         printf("Waiting for Slave...\n");
//         xSemaphoreTake(rdySem, portMAX_DELAY); // Čekání na Slave

//         ret = spi_device_transmit(handle, &t);
        
//         if (ret == ESP_OK) {
//             printf("Sent: %s\n", sendbuf);
//             printf("Received back: %s\n", recvbuf); // Tady už by měl být čistý text
//         }

//         n++;
//         vTaskDelay(pdMS_TO_TICKS(1000));
//     }
// }